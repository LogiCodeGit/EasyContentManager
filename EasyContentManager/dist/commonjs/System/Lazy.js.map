{"version":3,"sources":["System/Lazy.js","System/Lazy.ts"],"names":[],"mappings":";;;;AAIA;;;;;;;;;;ACGA,IAAA,iBAAA,QAA2B,gBAA3B,CAAA;AACA,IAAA,YAAA,QAA4B,YAA5B,CAAA;AACA,IAAM,YAAY,UAAA,OAAA;;IAIlB;;;AAGC,kBAAY,YAAZ,EAA4F;YAA1D,uEAAyB,qBAAiC;YAA1B,mEAAqB,qBAAK;;;;4FAErF,cAAc,gBAAgB,aAFuD;;AAG3F,cAAK,qBAAL,GAA6B,MAA7B,CAH2F;AAI3F,cAAK,eAAL,GAAuB,KAAvB,CAJ2F;;KAA5F;;;;+BAiBO,OAAa;AAEnB,mBAAO,QAAM,KAAN,CAFY;;;;oCAKR,OAAa;AAExB,mBAAO,KAAK,MAAL,CAAY,KAAZ,KAAsB,KAAK,KAAL,KAAa,MAAM,KAAN,CAFlB;;;;4BAfP;AAEjB,mBAAO,CAAC,CAAC,KAAK,eAAL,CAFQ;;;;4BAKT;AAER,mBAAO,KAAK,QAAL,EAAP,CAFQ;;;;;EAfmB,eAAA,YAAA;;AAAhB,QAAA,IAAA,GAAI,IAAJ;;IAgCb;;;AAEC,4BAAY,YAAZ,EAAgE;YAA9B,uEAAyB,qBAAK;;;;iGAEzD,cAAc,gBAAgB,OAF2B;KAAhE;;;EAFsC;;AAA1B,QAAA,cAAA,GAAc,cAAd;AAQb,OAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,OAAA,IAAA,EAAA;ADlBA,QAAQ,OAAR,GCkBe,IDlBf","file":"System/Lazy.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst ResolverBase_1 = require(\"./ResolverBase\");\nconst extends_1 = require(\"../extends\");\nconst __extends = extends_1.default;\nclass Lazy extends ResolverBase_1.ResolverBase {\n    constructor(valueFactory, trapExceptions = false, allowReset = false) {\n        super(valueFactory, trapExceptions, allowReset);\n        this._disposableObjectName = 'Lazy';\n        this._isValueCreated = false;\n    }\n    get isValueCreated() {\n        return !!this._isValueCreated;\n    }\n    get value() {\n        return this.getValue();\n    }\n    equals(other) {\n        return this == other;\n    }\n    valueEquals(other) {\n        return this.equals(other) || this.value === other.value;\n    }\n}\nexports.Lazy = Lazy;\nclass ResettableLazy extends Lazy {\n    constructor(valueFactory, trapExceptions = false) {\n        super(valueFactory, trapExceptions, true);\n    }\n}\nexports.ResettableLazy = ResettableLazy;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Lazy;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {ILazy} from \"./ILazy\";\r\nimport {Func} from \"./FunctionTypes\";\r\nimport {ResolverBase} from \"./ResolverBase\";\r\nimport __extendsImport from \"../extends\";\r\nconst __extends = __extendsImport;\r\n\r\n\r\n// We need a non-resettable lazy to ensure it can be passed safely around.\r\nexport class Lazy<T> extends ResolverBase<T> implements ILazy<T>\r\n{\r\n\r\n\tconstructor(valueFactory:Func<T>, trapExceptions:boolean = false, allowReset:boolean = false)\r\n\t{\r\n\t\tsuper(valueFactory, trapExceptions, allowReset);\r\n\t\tthis._disposableObjectName = 'Lazy';\r\n\t\tthis._isValueCreated = false;\r\n\t}\r\n\r\n\tget isValueCreated():boolean\r\n\t{\r\n\t\treturn !!this._isValueCreated;\r\n\t}\r\n\r\n\tget value():T\r\n\t{\r\n\t\treturn this.getValue();\r\n\t}\r\n\r\n\tequals(other:Lazy<T>):boolean\r\n\t{\r\n\t\treturn this==other;\r\n\t}\r\n\r\n\tvalueEquals(other:Lazy<T>):boolean\r\n\t{\r\n\t\treturn this.equals(other) || this.value===other.value;\r\n\t}\r\n\r\n}\r\n\r\nexport class ResettableLazy<T> extends Lazy<T>\r\n{\r\n\tconstructor(valueFactory:Func<T>, trapExceptions:boolean = false)\r\n\t{\r\n\t\tsuper(valueFactory, trapExceptions, true);\r\n\t}\r\n}\r\n\r\nexport default Lazy;"]}